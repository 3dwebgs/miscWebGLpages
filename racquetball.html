<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>RacketSmiley</title>
        <!-- Babylon.js -->
        <script src="http://www.babylonjs.com/hand.minified-1.2.js"></script>
        <script src="http://www.babylonjs.com/cannon.js"></script>
        <script src="http://www.babylonjs.com/oimo.js"></script>
        <script src="http://www.babylonjs.com/babylon.js"></script>
        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
	//http://babylonjs-playground.azurewebsites.net/#WHK49#7
	
	//stop surfaces from moving
	//adjust camera position.then decide whether to constrain view.
		
        var canvas = document.getElementById("renderCanvas");
        var engine = new BABYLON.Engine(canvas, true);

        var createScene = function () {
			var scene = new BABYLON.Scene(engine);
			var camera = new BABYLON.ArcRotateCamera("Camera", 0, 0, 10, new BABYLON.Vector3(0, 0, 0), scene);
			camera.setPosition(new BABYLON.Vector3(0, 50, 200));
			camera.lowerBetaLimit = 0.1;
			camera.upperBetaLimit = (Math.PI / 2) * 0.99;
			camera.lowerRadiusLimit = 150;
			scene.clearColor = new BABYLON.Color3(0.13, 0.11, 0.15);

			//ambient lighting
			var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(0, 1, 0), scene);
			light0.diffuse = new BABYLON.Color3(1, 1, 1);
			light0.specular = new BABYLON.Color3(1, 1, 1);
			light0.groundColor = new BABYLON.Color3(0, 0, 0);
			light0.intensity = 0.6;
			
			//Ground & wall planes
				
			var wallMaterial = new BABYLON.StandardMaterial("wallMat", scene);
			wallMaterial.specularColor = BABYLON.Color3.Black();
			var pi = Math.PI;
			
			var ground = BABYLON.Mesh.CreateGround("ground", 200, 400, 1, scene, false);
			ground.material = wallMaterial;
			
			var backWall = BABYLON.Mesh.CreatePlane("backWall", 200, scene);
			backWall.material = wallMaterial;
			backWall.position.y = 100;
			backWall.position.z = -200;
			backWall.rotation = new BABYLON.Vector3(0, Math.PI, 0);
			

			var leftWall = BABYLON.MeshBuilder.CreatePlane("leftWall", {width:400,height:200, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
			leftWall.material = wallMaterial;
			leftWall.position = new BABYLON.Vector3(100, 100, 0);
			leftWall.rotation = new BABYLON.Vector3(0, pi/2, 0);

			var rightWall = BABYLON.MeshBuilder.CreatePlane("rightWall", {width:400,height:200, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
			rightWall.material = wallMaterial;
			rightWall.position = new BABYLON.Vector3(-100, 100, 0);
			rightWall.rotation = new BABYLON.Vector3(0, pi/2, 0);

			
			
			//racquet- sort of - will add back in later.
			/*var plane = BABYLON.Mesh.CreatePlane("plane", 20, scene);
			var planeMat = new BABYLON.StandardMaterial("planeMat", scene);
			planeMat.diffuseColor = new BABYLON.Color3(0.28,1.43,1.43);
			planeMat.alpha = 0.5;
			plane.material = planeMat;
			plane.position.z = 100; 
			plane.position.y = 20; 
			plane.rotation = new BABYLON.Vector3(0, Math.PI, 0);*/

			// ball
			var redSphere = BABYLON.Mesh.CreateSphere("red", 16, 10, scene);
			var redMat = new BABYLON.StandardMaterial("redmaterial", scene);
			redMat.diffuseColor = new BABYLON.Color3(0.4, 0.4, 0.4);
			redMat.specularColor = new BABYLON.Color3(0.4, 0.4, 0.4);
			redMat.emissiveColor = BABYLON.Color3.Red();
			redSphere.material = redMat;
			redSphere.position.y = 10;
			redSphere.position.x -= 0;


			// Events
		  
			
			var canvas = engine.getRenderingCanvas();
			var startingPoint;
			var currentMesh;

			var getGroundPosition = function () {
				// Use a predicate to get position on the ground
				var pickinfo = scene.pick(scene.pointerX, scene.pointerY);//, function (mesh) { return mesh == ground; });
				if (pickinfo.hit) {
					return pickinfo.pickedPoint;
				}

				return null;
			}

			var onPointerDown = function (evt) {
				if (evt.button !== 0) {
					return;
				}

				// check if we are under a mesh
				var pickInfo = scene.pick(scene.pointerX, scene.pointerY);//, function (mesh) { return mesh !== ground; });
				if (pickInfo.hit) {
					currentMesh = pickInfo.pickedMesh;
					startingPoint = getGroundPosition();

					if (startingPoint) { // disconnect camera from canvas
						setTimeout(function () {
							camera.detachControl(canvas);
						}, 0);
					}
				}
			}

			var onPointerUp = function () {
				if (startingPoint) {
					camera.attachControl(canvas, true);
					startingPoint = null;
					return;
				}
			}

			var onPointerMove = function () {
				if (!startingPoint) {
					return;
				}

				var current = getGroundPosition();

				if (!current) {
					return;
				}

				// changes the position.
				var diff = current.subtract(startingPoint);
				currentMesh.position.addInPlace(diff);

				startingPoint = current;

			}

			canvas.addEventListener("pointerdown", onPointerDown, false);
			canvas.addEventListener("pointerup", onPointerUp, false);
			canvas.addEventListener("pointermove", onPointerMove, false);

			scene.onDispose = function () {
				canvas.removeEventListener("pointerdown", onPointerDown);
				canvas.removeEventListener("pointerup", onPointerUp);
				canvas.removeEventListener("pointermove", onPointerMove);
			}

			return scene;
        };
        
        var scene = createScene();

        engine.runRenderLoop(function () {
            scene.render();
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>
